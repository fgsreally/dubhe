import{_ as e,o as c,c as d,a as o}from"./app.c7558d4a.js";const m=JSON.parse('{"title":"原理","description":"","frontmatter":{},"headers":[{"level":2,"title":"对于js模块","slug":"对于js模块","link":"#对于js模块","children":[]},{"level":2,"title":"静态资源","slug":"静态资源","link":"#静态资源","children":[{"level":3,"title":"css","slug":"css","link":"#css","children":[]}]}],"relativePath":"base/core.md","lastUpdated":1690295205000}'),s={name:"base/core.md"},a=o('<h1 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-hidden="true">#</a></h1><p><code>dubhe</code>本质十分简单，流程如下:</p><h2 id="对于js模块" tabindex="-1">对于js模块 <a class="header-anchor" href="#对于js模块" aria-hidden="true">#</a></h2><ol><li>生产端正常打包，并将共有依赖给<code>external</code>，</li><li>消费端在开发时，获得这些模块缓存在本地，并创建虚拟模块指向缓存，同样远程获得类型，此时体验与<code>npm</code>包无异。</li><li>当生产端开启<code>watch</code>模式打包，会通知消费端<code>devserver</code>使其及时更新缓存。</li><li>当消费端打包时，如果是冷模式，就会正常将其打包，如果是热模式，将会把这些虚拟模块<code>external</code>掉，最后通过<code>importmap</code>/<code>systemjs importmap</code>注入共有依赖和远程模块的<code>cdn</code>。</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>冷模式更像是带热更新的<code>npm</code>包，热模式更像是<code>模块联邦</code></p></div><h2 id="静态资源" tabindex="-1">静态资源 <a class="header-anchor" href="#静态资源" aria-hidden="true">#</a></h2><p><code>dubhe</code>关于图片等资源的处理，可以是以<code>base64</code>可以是路径，这取决于打包器中的配置，但这里的路径是指生产端放置资源的位置(<code>url</code>)，如果生产端资源放在内网，使用冷模式打包，其他东西都没有影响，但图片指向的地址在内网，自然获取不到。</p><h3 id="css" tabindex="-1">css <a class="header-anchor" href="#css" aria-hidden="true">#</a></h3><p>关于<code>css</code>的处理可能具备潜在问题，现在是默认将<code>css</code>全部转成<code>js</code>,也就是把样式全转成文本，然后创建一个<code>style</code>标签往<code>head</code>里面挂。所以目前<code>dubhe</code>只支持<code>web</code>平台，后续会考虑其他</p><blockquote><p>这里或许不一定是个好的处理，内部的版本之前采用的仍是保留正常<code>css</code>，但这让调试/维护/热更新变得异常玄幻。 现在生产端，只会生产出<code>js</code>和静态资源，无<code>css</code>。</p></blockquote>',10),t=[a];function l(r,i,n,h,p,_){return c(),d("div",null,t)}const b=e(s,[["render",l]]);export{m as __pageData,b as default};
