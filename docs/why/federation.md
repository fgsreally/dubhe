## 为什么模块联邦不一定是一个好方案

我不觉得模块联邦是一个好方案，原因有两个：成熟度和热模式

# 成熟度
我见过起码一百个微前端方案调研，里面都莫名其妙调研了模块联邦，而且最后没有一个真正采用了（其中很多人根本没有沙箱的需求，结果还是使用了qiankun)。原因很简单，既有工具链的限制（仅用于webpack5，如果能支持4的话情况会好很多），又没有配套的工具（类型导出没有，共用依赖管理没有）。后者逼迫开发者要自己做相关建设，前者却又只能吓退开发者。

> 大概情况就是你辛辛苦苦在远程模块中导出，并设置共享依赖，再在基模块中填好配置，然后vscode一片红（类型报错）


# 热模式
如果你尝试过生产级别的bundless，比如esm.sh，你可能会遇上瀑布流（请求数量多，且请求的新文件又会再去嵌套请求），其中很多请求可能内容很少，完全不值得一次请求，而且得到的不同文件，继续请求的文件数目，体积大小都可能不同。
显然，要解决这种情况，需要做一些预处理（好吧，你可能已经想到vite了，但这比vite还要复杂），也就是分析所有的依赖，并进行分配...

> 真实情况中，bundless并不是不打包，只是换了一种打包的形式

> 我这里假设所有的模块不存在安全隐患，不存在全局破坏行为，不存在内存泄漏，即使如此问题依然不少

## 情况1
所有的沿袭模块联邦的，基于运行时的方案（跑起来才到对应模块中去请求），和上述情况一样，要么蛮不讲理打包成一个or几个，让消费端去头疼（消费端只需要一个模块，结果得到一整个库，无数的模块），要么自己想办法去做分析并分包（即使是这样，也必然会多出一个请求去取元数据）

## 情况2
好吧，我们先对性能这回事睁一只眼闭一只眼（至少，项目在存在大量的嵌套依赖等问题之前，这好像影响不大），但问题并不仅有这个。
注意一下，模块联邦方案，或者所有类似的基于运行时的方案，都是强一致性的，也就是项目一升版本，所有依赖的项目都自动升，这在很多时候是个优点，但糟糕的是，强一致是强制而非可选的特性，如果我要调整一个组件的props，我或许要把所有依赖项目中调用此组件的部分进行改造；如果有一个项目，已经开发完全、功能稳定了，我不希望它再去一味的跟进版本了。我没有办法为这些情况提供降级的方案，最后任何一个组件的更动，都会导致所有项目变化，我唯一能做的就是在提交代码之前进行祈祷，然后在提交代码后开始准备回滚

## 情况3
好吧，假设我们坚持使用装饰器模式去涉及，使得调用方式永不改变，那如果试图对远程组件进行改造，比如注入一段样式，那么在组件更新版本后，scopedID 或 css modules生成的值会变化，这段注入的样式基本又要重写了
> 如果不用这种规范的方式去隔离css，而是用某种方便的东西去自动隔离的话，以shadow dom 为例，不约束这个组件内部往shadowDom 以外的地方去挂载的话，就不能完全样式隔离，而如果试图约束这种挂载方式，那相当于在做一个js沙箱，那干脆直接考虑qiankun之类的东西吧



>有些方案，要么专注于导出（压根没有源项目，完全当作一个多仓库），要么不影响源项目，只是单独做了一个导出的打包。而 模块联邦严格意义上，应该算是岛模式。也就是源项目中的一部分被拆出来，当作岛屿，当源项目or 其他项目需要时，就调用这座岛屿。这其实会更糟，意味着你甚至会破坏源项目的分包结构，对源项目产生影响。