import{_ as e,o as a,c as t,a as o}from"./app.c7558d4a.js";const b=JSON.parse('{"title":"成熟度","description":"","frontmatter":{},"headers":[{"level":2,"title":"为什么模块联邦不一定是一个好方案","slug":"为什么模块联邦不一定是一个好方案","link":"#为什么模块联邦不一定是一个好方案","children":[]},{"level":2,"title":"情况1","slug":"情况1","link":"#情况1","children":[]},{"level":2,"title":"情况2","slug":"情况2","link":"#情况2","children":[]},{"level":2,"title":"情况3","slug":"情况3","link":"#情况3","children":[]}],"relativePath":"why/federation.md","lastUpdated":1692708894000}'),d={name:"why/federation.md"},r=o('<h2 id="为什么模块联邦不一定是一个好方案" tabindex="-1">为什么模块联邦不一定是一个好方案 <a class="header-anchor" href="#为什么模块联邦不一定是一个好方案" aria-hidden="true">#</a></h2><p>我不觉得模块联邦是一个好方案，原因有两个：成熟度和热模式</p><h1 id="成熟度" tabindex="-1">成熟度 <a class="header-anchor" href="#成熟度" aria-hidden="true">#</a></h1><p>我见过起码一百个微前端方案调研，里面都莫名其妙调研了模块联邦，而且最后没有一个真正采用了（其中很多人根本没有沙箱的需求，结果还是使用了qiankun）。原因很简单，既有工具链的限制（仅用于webpack5，如果能支持4的话情况会好很多），又没有配套的工具（现在社区倒是有了）。后者逼迫开发者要自己做相关建设，前者却又只能吓退开发者。</p><blockquote><p>大概情况就是你辛辛苦苦在远程模块中导出，并设置共享依赖，再在基模块中填好配置，然后vscode一片红（类型报错）</p></blockquote><h1 id="热模式" tabindex="-1">热模式 <a class="header-anchor" href="#热模式" aria-hidden="true">#</a></h1><p>如果你尝试过生产级别的bundless，比如esm.sh，你可能会遇上瀑布流（请求数量多，且请求的新文件又会再去嵌套请求），其中很多请求可能内容很少，完全不值得一次请求，而且得到的不同文件，继续请求的文件数目，体积大小都可能不同。 显然，要解决这种情况，需要做一些预处理（好吧，你可能已经想到vite了，但这比vite还要复杂），也就是分析所有的依赖，并进行分配...</p><blockquote><p>真实情况中，bundless并不是不打包，只是换了一种打包的形式</p></blockquote><blockquote><p>我这里假设所有的模块不存在安全隐患，不存在全局破坏行为，不存在内存泄漏，即使如此问题依然不少</p></blockquote><h2 id="情况1" tabindex="-1">情况1 <a class="header-anchor" href="#情况1" aria-hidden="true">#</a></h2><p>所有的沿袭模块联邦的，基于运行时的方案（跑起来才到对应模块中去请求），和上述情况一样，要么蛮不讲理打包成一个or几个，让消费端去头疼（消费端只需要一个模块，结果得到一整个库，无数的模块），要么自己想办法去做分析并分包（即使是这样，也必然会多出一个请求去取元数据）</p><h2 id="情况2" tabindex="-1">情况2 <a class="header-anchor" href="#情况2" aria-hidden="true">#</a></h2><p>好吧，我们先对性能这回事睁一只眼闭一只眼（至少，项目在存在大量的嵌套依赖等问题之前，这好像影响不大），但问题并不仅有这个。 注意一下，模块联邦方案，或者所有类似的基于运行时的方案，都是强一致性的，也就是项目一升版本，所有依赖的项目都自动升，这在很多时候是个优点，但糟糕的是，强一致是强制而非可选的特性，如果我要调整一个组件的props，我或许要把所有依赖项目中调用此组件的部分进行改造；如果有一个项目，已经开发完全、功能稳定了，我不希望它再去一味的跟进版本了。我没有办法为这些情况提供降级的方案，最后任何一个组件的更动，都会导致所有项目变化，我唯一能做的就是在提交代码之前进行祈祷，然后在提交代码后开始准备回滚</p><h2 id="情况3" tabindex="-1">情况3 <a class="header-anchor" href="#情况3" aria-hidden="true">#</a></h2><p>好吧，假设我们坚持使用装饰器模式去涉及，使得调用方式永不改变，那如果试图对远程组件进行改造，比如注入一段样式，那么在组件更新版本后，scopedID 或 css modules生成的值会变化，这段注入的样式基本又要重写了</p><blockquote><p>如果不用这种规范的方式去隔离css，而是用某种方便的东西去自动隔离的话，以shadow dom 为例，不约束这个组件内部往shadowDom 以外的地方去挂载的话，就不能完全样式隔离，而如果试图约束这种挂载方式，那相当于在做一个js沙箱，那干脆直接考虑qiankun之类的东西吧</p></blockquote><blockquote><p>有些方案，要么专注于导出（压根没有源项目，完全当作一个多仓库），要么不影响源项目，只是单独做了一个导出的打包。而 模块联邦严格意义上，应该算是岛模式。也就是源项目中的一部分被拆出来，当作岛屿，当源项目or 其他项目需要时，就调用这座岛屿。这其实会更糟，意味着你甚至会破坏源项目的分包结构，对源项目产生影响。</p></blockquote>',17),i=[r];function s(n,l,c,h,p,u){return a(),t("div",null,i)}const k=e(d,[["render",s]]);export{b as __pageData,k as default};
