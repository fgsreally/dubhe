import{_ as e,o as t,c as a,a as i}from"./app.c7558d4a.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"相比于其他微前端方案","slug":"相比于其他微前端方案","link":"#相比于其他微前端方案","children":[]},{"level":2,"title":"穿越时间线的飞刀","slug":"穿越时间线的飞刀","link":"#穿越时间线的飞刀","children":[]},{"level":2,"title":"没必要大动干戈","slug":"没必要大动干戈","link":"#没必要大动干戈","children":[]}],"relativePath":"why/micro.md","lastUpdated":1692350205000}'),l={name:"why/micro.md"},r=i('<h2 id="相比于其他微前端方案" tabindex="-1">相比于其他微前端方案 <a class="header-anchor" href="#相比于其他微前端方案" aria-hidden="true">#</a></h2><p>严格来讲，微前端有两类，微应用和微模块（根据粒度来分也行，根据js-entry/html-entry来分也行，根据是否提供沙箱来分也行，因为一般来讲这些是配套的选项），前者像是iframe 后者像是组件库/工具库。dubhe是一种微模块的方案。</p><h2 id="穿越时间线的飞刀" tabindex="-1">穿越时间线的飞刀 <a class="header-anchor" href="#穿越时间线的飞刀" aria-hidden="true">#</a></h2><p>假设你现在接手一个三年前的项目，做这个项目的同事（或许就是你自己）不怀好意的在全局挂了个对象，你就要在jQuery的漫天$中漫无目的的寻找一行未知的代码，同时你新写下的，自以为完美无缺的代码，也会让多年后在使用react99,vue8的你破口大骂...</p><p>如果对于你来讲最重要的是，</p><ol><li>项目具有长时间的生命力，而不是随着vue等框架升级直接开摆</li><li>老项目爱咋样咋样，开发者优先开摆 微应用显然更合适。</li></ol><blockquote><p>所有的微应用类的库，基本都有着孱弱的通信机制和依赖共享机制，因为微应用的这种逻辑，本质上就不希望你在多个应用之间滑滑梯 为啥不使用iframe：如果不做任何操作的话，iframe本身就是一把飞刀</p></blockquote><h2 id="没必要大动干戈" tabindex="-1">没必要大动干戈 <a class="header-anchor" href="#没必要大动干戈" aria-hidden="true">#</a></h2><p>如果这个项目大概率活不过你，或者项目不能跑了你还能跑，三年前的飞刀压根找不到你，你只是单纯觉得这个项目太大，管理困难</p><p>如果对于你来讲最重要的是，</p><ol><li>项目划分</li><li>更多的操作空间 这才适合微模块</li></ol><blockquote><p>模块联邦算是一种方案，但我相信没有公司会原封不动地用它， npm包其实也是一种方案，如果你对联调没有需求的话 bit 也算，如果官方自己能好好做的话</p></blockquote>',12),o=[r];function c(n,d,s,h,p,_){return t(),a("div",null,o)}const f=e(l,[["render",c]]);export{m as __pageData,f as default};
